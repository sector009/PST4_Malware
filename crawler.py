GOOGLE_LOGIN = GOOGLE_PASSWORD = AUTH_TOKEN = None
ANDROID_ID = None
DOWNLOAD_PATH = '/home/alex/googleplay/'


FOUND_APP = [] # List shared between threads
LOCK = 0

DICO = []
SPLITED_DICO = []

from googleplay import  GooglePlayAPI
import sys
import os
import urlparse
import time
import random
import threading

from helpers import sizeof_fmt, print_header_line, print_result_line
from config import *

def downloadApps(api,packagename,filename):
	# Get the version code and the offer type from the app details
	m = api.details(packagename)
	doc = m.docV2
	vc = doc.details.appDetails.versionCode
	ot = doc.offer[0].offerType

	# Download
	print "Downloading %s... \n" % sizeof_fmt(doc.details.appDetails.installationSize),
	data = api.download(packagename, vc, ot)
	open(filename, "wb").write(data)
	print "Done"


def crawlAll(id):
    # declared as global in order for changes to be acknowledged by every threads
    global FOUND_APP
    global LOCK

    api = GooglePlayAPI(ANDROID_ID[id])
    api.login(GOOGLE_LOGIN[id], GOOGLE_PASSWORD[id], AUTH_TOKEN)
    user = id
     
        
    for word in SPLITED_DICO[id]:
        
        try:
            message = api.search(word, 250) # Search the playstore with the word
        except:
            print "Error: HTTP 500 - one of the provided parameters is invalid"
            return 0
        
        try:
            doc = message.doc[0]
        except IndexError: # if we were blocked
            print "Blocked, switching Account"
            user += THREAD_NUMBER
            if user >= len(ANDROID_ID):
                user = id
            print GOOGLE_LOGIN[user]
            
            time.sleep(4) # Wait a bit before connecting again
            del api
            api = GooglePlayAPI(ANDROID_ID[user], LANG)
            api.login(GOOGLE_LOGIN[user], GOOGLE_PASSWORD[user], None) # attempt another connection
            continue

        for c in doc.child:
            try:
                #print_result_line(c)

                package = c.docid
                while LOCK == 1: # prevent reading while other thread is writing
                    pass
                if package in FOUND_APP: # if app was found in a previous search 
                    continue
                name = c.title                  
                length = c.details.appDetails.installationSize/(1024*1024)

                l = [package, name, str(length) + "MB"]
                print SEPARATOR.join(unicode(i).encode('utf8') for i in l)

                while LOCK == 1: # prevent writing when other thread is writing
                    pass
                LOCK = 1 # Acquire lock
                FOUND_APP.append(package) # commit change
                LOCK = 0 # release lock
                print "\nNumber Of app = " + str(len(FOUND_APP))
                
                if length > 0: # if apk is more than 1 MB
                    print 'too large, skip'
                    continue
        
                folder = DOWNLOAD_PATH
                if not os.path.exists(folder):
                    os.mkdir(folder)
                filename = folder + '/' + name + '.apk'
                if not os.path.isfile(filename):
                    downloadApps(api,package,filename)       
                

            except:
                continue
    return FOUND_APP


if __name__ == '__main__':
    #get categories
    
    workers = []

    for i in range(THREAD_NUMBER):
        print "i = " + str(i)
        SPLITED_DICO.append([])


    print "Loading Dictionary ..."
    with open('/usr/share/dict/wordsList','r') as f:
        DICO = f.readlines()
    
    print "Shuffling Dictionary ..."
    random.shuffle(DICO)

    print "Spliting Dictionary between threads ..."
    i = 0
    for w in DICO:
        SPLITED_DICO[i%THREAD_NUMBER].append(w)
        i += 1
    del DICO

    for i in range(THREAD_NUMBER):
        print "Launching Workers #" + str(i)
        workers.append(threading.Thread(target=crawlAll, args=([i])))
        workers[i].start()

    for i in range(THREAD_NUMBER):
        workers[i].join() # Block app until all threads are done
        

    with open('/home/alex/Bureau/apps.txt', 'w') as appstxt:
        for p in FOUND_APP:
            print>>appstxt, p
        
    print 'google play crawler is done'
